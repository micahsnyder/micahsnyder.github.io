<!DOCTYPE html>
<html>

<head>
  
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Error Handling in C</title>
<link href='https://fonts.googleapis.com/css?family=Muli:400,300' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Lobster%20Two:400,300' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Fira%20Code:400,300' rel='stylesheet' type='text/css'>
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha256-3dkvEK0WLHRJ7/Csr0BZjAWxERc5WH7bdeUya2aXxdU= sha512-+L4yy6FRcDGbXJ9mPG8MT/3UCDzwR9gPeyFNMCtInsol++5m3bk2bXWKdZjvybmohrAsn3Ua5x8gfLnbE1YkOg==" crossorigin="anonymous">
<link rel="stylesheet" href="/writ.min.css">
<link rel="stylesheet" href="/style.css" type="text/css" media="all" />
<link rel="alternate" href="/rss.xml" type="application/rss+xml" title="RSS" />

</head>

<body>
  <header>
    <header>
   <h2>Micah Snyder's blog</h2>
</header>
  </header>

  <div class="outerDiv">
    <div class="leftDiv">
      <h1>Error Handling in C</h1>
<p>2020-12-11 07:32:15 +0000</p>
<hr />
<p>It is far too easy for C code to spring memory leaks due to shoddy error handling. In a larger code base poor error handling habits can result in years of agony tracking down bugs and digging out from small mountain of technical debt.</p>
<p>No thanks to Edsger Dijkstra's infamous 1968 letter &quot;Go To Statement Considered Harmful&quot;, just about every C programmer has been told at one time that <code>goto</code> is &quot;bad&quot;. This still rings true except for one use of <code>goto</code>: error handling.</p>
<p>In this article I'll present an overview of a few different error handling methods available to the C programmer. To illustrate, I've crated example multi-threaded application that stores named data-elements in a global growable array protected by a mutex. The function in our example adds one element to the array, and allocates more space for the array as needed.</p>
<p>By the end of this article, I hope you'll agree with me on the best option for error handling in C (<em>hint</em>: it's <code>goto</code>).</p>
<h2>Multiple <code>return</code>'s</h2>
<p>Perhaps the most common method for error handling, especially in older C code involves the use of multiple <code>return</code> statements. Allocated memory, thread locks, and other resources are cleaned up as-needed at each <code>return</code>.</p>
<p>Without further ado, here's our first variant of the example program featuring the &quot;Multiple <code>return</code>s&quot; error handling method:</p>
<pre style="background-color:#2d2d2d;">
<span style="background-color:#2d2d2d;color:#747369;">/* Standard libs */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;stdbool.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;    </span><span style="background-color:#2d2d2d;color:#747369;">/* For bool */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;stdint.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;     </span><span style="background-color:#2d2d2d;color:#747369;">/* For modern integer types */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;stdlib.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;     </span><span style="background-color:#2d2d2d;color:#747369;">/* For malloc/free */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;string.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;     </span><span style="background-color:#2d2d2d;color:#747369;">/* For strdup */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;stdio.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;      </span><span style="background-color:#2d2d2d;color:#747369;">/* For printf */

/* 3rd-party Libs */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;pthread.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;

</span><span style="background-color:#2d2d2d;color:#cc99cc;">typedef struct </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">char </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* name;
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">void </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* data;
} named_data_t;

</span><span style="background-color:#2d2d2d;color:#747369;">/* We&#39;ll allocate the array of data pointers in increments of 100 */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#define DATA_ARRAY_BLOCK_SIZE </span><span style="background-color:#2d2d2d;color:#f99157;">100

</span><span style="background-color:#2d2d2d;color:#cc99cc;">static </span><span style="background-color:#2d2d2d;color:#d3d0c8;">pthread_mutex_t data_array_lock = PTHREAD_MUTEX_INITIALIZER;
</span><span style="background-color:#2d2d2d;color:#cc99cc;">static</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> named_data_t ** g_data_array = </span><span style="background-color:#2d2d2d;color:#f99157;">NULL</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
</span><span style="background-color:#2d2d2d;color:#cc99cc;">static </span><span style="background-color:#2d2d2d;color:#d3d0c8;">size_t g_data_array_size = </span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;    </span><span style="background-color:#2d2d2d;color:#747369;">/* Size of array (in element) */
</span><span style="background-color:#2d2d2d;color:#cc99cc;">static </span><span style="background-color:#2d2d2d;color:#d3d0c8;">size_t g_num_data_elements = </span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;  </span><span style="background-color:#2d2d2d;color:#747369;">/* Number of element in array */

/**
 * @brief Add a new named data element to the global array.
 *
 * @param name      Element name
 * @param data      Pointer to the element data
 * @return true     Element successfully added.
 * @return false    Failed to add element.
 */
</span><span style="background-color:#2d2d2d;color:#cc99cc;">bool </span><span style="background-color:#2d2d2d;color:#6699cc;">append_data_element</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#cc99cc;">const char </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* name, </span><span style="background-color:#2d2d2d;color:#cc99cc;">void </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* data) {
    named_data_t *new_element = </span><span style="background-color:#2d2d2d;color:#f99157;">NULL</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== name || </span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== data) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Bad args! */
        </span><span style="background-color:#2d2d2d;color:#66cccc;">printf</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&quot;</span><span style="background-color:#2d2d2d;color:#99cc99;">add_named_rectangle: Invalid arguments!</span><span style="background-color:#2d2d2d;color:#66cccc;">\n</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;);
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">return </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    }

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Allocate a new struct to put on our array. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
    new_element = </span><span style="background-color:#2d2d2d;color:#66cccc;">malloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(sizeof(named_data_t));
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== new_element) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Out of memory! */
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">return </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    }

    </span><span style="background-color:#2d2d2d;color:#747369;">/* We don&#39;t own the name, so let&#39;s duplicate it. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
    new_element-&gt;name = </span><span style="background-color:#2d2d2d;color:#6699cc;">strdup</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(name);
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== new_element-&gt;name) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Out of memory! */
        </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element);
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">return </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    }

    </span><span style="background-color:#2d2d2d;color:#747369;">/* We&#39;re being given ownership of the data, so we&#39;ll just assign the pointer. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
    new_element-&gt;name = data;

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Lock the array so we can safely add our new element. */
    </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_lock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);

    </span><span style="background-color:#2d2d2d;color:#747369;">/*
     * Append our data element to the end of the array.
     */
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== g_data_array) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Array doesn&#39;t exist, let&#39;s allocate it */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">

        g_data_array = </span><span style="background-color:#2d2d2d;color:#66cccc;">malloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(DATA_ARRAY_BLOCK_SIZE * sizeof(named_data_t*));
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== g_data_array) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Failed to allocate memory for data array! */
            </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element-&gt;name);
            </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element);
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">return </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
        }

        g_data_array_size = DATA_ARRAY_BLOCK_SIZE;

    } </span><span style="background-color:#2d2d2d;color:#cc99cc;">else if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(g_num_data_elements == g_data_array_size) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Array is full, allocate more memory */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
        named_data_t ** temp;

        temp = </span><span style="background-color:#2d2d2d;color:#66cccc;">realloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(g_data_array, (g_data_array_size + DATA_ARRAY_BLOCK_SIZE) * sizeof(named_data_t*));
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== temp) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Failed to increase size of data array! */
            </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element-&gt;name);
            </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element);
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">return </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
        }

        g_data_array = temp;
        g_data_array_size += DATA_ARRAY_BLOCK_SIZE;
    }

    g_data_array[g_num_data_elements] = new_element;
    g_num_data_elements += </span><span style="background-color:#2d2d2d;color:#f99157;">1</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Unlock the array so other threads can access it once more. */
    </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_unlock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);

    </span><span style="background-color:#2d2d2d;color:#66cccc;">printf</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&quot;</span><span style="background-color:#2d2d2d;color:#99cc99;">add_named_rectangle: Added &#39;</span><span style="background-color:#2d2d2d;color:#f99157;">%s</span><span style="background-color:#2d2d2d;color:#99cc99;">&#39; element to data array!</span><span style="background-color:#2d2d2d;color:#66cccc;">\n</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;, name);

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">return </span><span style="background-color:#2d2d2d;color:#f99157;">true</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
}
</span></pre>
<p>As you review the above example, note how much duplicate code exists for resource cleanup during error handling. Can you see how easy it would be to forget to clean up a malloced pointer or a locked mutex. This is a recipe for disaster!</p>
<h2>The <code>do { ... } while(0)</code></h2>
<p>Another surprisingly popular option for error handling in C is to wrap all function code in a big ol' <code>do { ... } while(0);</code> &quot;loop&quot;.</p>
<p>I'm not a big fan of the <code>do { ... } while(0);</code> approach to error handling for a few reasons...</p>
<p>First and foremost, it's an obvious hack to perform a <code>goto</code> without using the word <code>goto</code>!</p>
<p>Secondly, it's confusing. To the novice programmer, this approach for error handling is non-obvious because it abuses the do-while looping construct to perform a completely different task. An experienced programmer may appreciate such cleverness but the simple fact is that code which is hard to read is hard to maintain and increases the barrier to entry for novice programmers with little if any real benefit.</p>
<p>Additionally, I think the extra indentation of the  <code>do { ... } while(0);</code> is harder to read.</p>
<p>Here's our example using the do-while method:</p>
<pre style="background-color:#2d2d2d;">
<span style="background-color:#2d2d2d;color:#747369;">/* Standard libs */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;stdbool.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;    </span><span style="background-color:#2d2d2d;color:#747369;">/* For bool */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;stdint.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;     </span><span style="background-color:#2d2d2d;color:#747369;">/* For modern integer types */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;stdlib.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;     </span><span style="background-color:#2d2d2d;color:#747369;">/* For malloc/free */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;string.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;     </span><span style="background-color:#2d2d2d;color:#747369;">/* For strdup */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;stdio.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;      </span><span style="background-color:#2d2d2d;color:#747369;">/* For printf */

/* 3rd-party Libs */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;pthread.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;

</span><span style="background-color:#2d2d2d;color:#cc99cc;">typedef struct </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">char </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* name;
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">void </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* data;
} named_data_t;

</span><span style="background-color:#2d2d2d;color:#747369;">/* We&#39;ll allocate the array of data pointers in increments of 100 */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#define DATA_ARRAY_BLOCK_SIZE </span><span style="background-color:#2d2d2d;color:#f99157;">100

</span><span style="background-color:#2d2d2d;color:#cc99cc;">static </span><span style="background-color:#2d2d2d;color:#d3d0c8;">pthread_mutex_t data_array_lock = PTHREAD_MUTEX_INITIALIZER;
</span><span style="background-color:#2d2d2d;color:#cc99cc;">static</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> named_data_t ** g_data_array = </span><span style="background-color:#2d2d2d;color:#f99157;">NULL</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
</span><span style="background-color:#2d2d2d;color:#cc99cc;">static </span><span style="background-color:#2d2d2d;color:#d3d0c8;">size_t g_data_array_size = </span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;    </span><span style="background-color:#2d2d2d;color:#747369;">/* Size of array (in element) */
</span><span style="background-color:#2d2d2d;color:#cc99cc;">static </span><span style="background-color:#2d2d2d;color:#d3d0c8;">size_t g_num_data_elements = </span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;  </span><span style="background-color:#2d2d2d;color:#747369;">/* Number of element in array */

/**
 * @brief Add a new named data element to the global array.
 *
 * @param name      Element name
 * @param data      Pointer to the element data
 * @return true     Element successfully added.
 * @return false    Failed to add element.
 */
</span><span style="background-color:#2d2d2d;color:#cc99cc;">bool </span><span style="background-color:#2d2d2d;color:#6699cc;">append_data_element</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#cc99cc;">const char </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* name, </span><span style="background-color:#2d2d2d;color:#cc99cc;">void </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* data) {
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">bool</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status = </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    named_data_t *new_element = </span><span style="background-color:#2d2d2d;color:#f99157;">NULL</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">do </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== name || </span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== data) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Bad args! */
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">break</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
        }

        </span><span style="background-color:#2d2d2d;color:#747369;">/* Allocate a new struct to put on our array. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
        new_element = </span><span style="background-color:#2d2d2d;color:#66cccc;">malloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(sizeof(named_data_t));
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== new_element) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Out of memory! */
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">break</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
        }

        </span><span style="background-color:#2d2d2d;color:#747369;">/* We don&#39;t own the name, so let&#39;s duplicate it. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
        new_element-&gt;name = </span><span style="background-color:#2d2d2d;color:#6699cc;">strdup</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(name);
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== new_element-&gt;name) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Out of memory! */
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">break</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
        }

        </span><span style="background-color:#2d2d2d;color:#747369;">/* We&#39;re being given ownership of the data, so we&#39;ll just assign the pointer. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
        new_element-&gt;name = data;

        </span><span style="background-color:#2d2d2d;color:#747369;">/* Lock the array so we can safely add our new element. */
        </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_lock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);

        </span><span style="background-color:#2d2d2d;color:#747369;">/*
         * Append our data element to the end of the array.
         */
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== g_data_array) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Array doesn&#39;t exist, let&#39;s allocate it */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">

            g_data_array = </span><span style="background-color:#2d2d2d;color:#66cccc;">malloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(DATA_ARRAY_BLOCK_SIZE * sizeof(named_data_t*));
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== g_data_array) {
                </span><span style="background-color:#2d2d2d;color:#747369;">/* Failed to allocate memory for data array! */
                </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_unlock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);  </span><span style="background-color:#2d2d2d;color:#747369;">/* !! We still have to unlock the mutex before we break */
                </span><span style="background-color:#2d2d2d;color:#cc99cc;">break</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
            }

            g_data_array_size = DATA_ARRAY_BLOCK_SIZE;

        } </span><span style="background-color:#2d2d2d;color:#cc99cc;">else if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(g_num_data_elements == g_data_array_size) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Array is full, allocate more memory */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
            named_data_t ** temp;

            temp = </span><span style="background-color:#2d2d2d;color:#66cccc;">realloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(g_data_array, (g_data_array_size + DATA_ARRAY_BLOCK_SIZE) * sizeof(named_data_t*));
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== temp) {
                </span><span style="background-color:#2d2d2d;color:#747369;">/* Failed to increase size of data array! */
                </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_unlock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);  </span><span style="background-color:#2d2d2d;color:#747369;">/* !! We still have to unlock the mutex before we break */
                </span><span style="background-color:#2d2d2d;color:#cc99cc;">break</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
            }
            g_data_array = temp;
            g_data_array_size += DATA_ARRAY_BLOCK_SIZE;
        }

        g_data_array[g_num_data_elements] = new_element;
        g_num_data_elements += </span><span style="background-color:#2d2d2d;color:#f99157;">1</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

        </span><span style="background-color:#2d2d2d;color:#747369;">/* Unlock the array so other threads can access it once more. */
        </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_unlock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);

        </span><span style="background-color:#2d2d2d;color:#747369;">/* Success! */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
        status = </span><span style="background-color:#2d2d2d;color:#f99157;">true</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    } </span><span style="background-color:#2d2d2d;color:#cc99cc;">while</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">);

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">false </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== status) {
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">!= new_element) {
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">!= new_element-&gt;name) {
                </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element-&gt;name);
            }
            </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element);
        }
    }

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">return</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status;
}
</span></pre>
<p>But the real reason this method is bad is that it isn't as flexible as using <code>goto</code> for error handling. Here are a couple ways in which the do-while approach to error-handling and resource cleanup breaks down:</p>
<ol>
<li>
<p>You can't have multiple exit points. With the <code>goto</code>, you can have more than one label if you have different ways of cleaning up. In the do-while example above, you'll see that a lack of multiple labels mean we still have to unlock the mutex before our <code>break</code> as there's no way to check if we'd locked the mutex without adding an extra variable.</p>
</li>
<li>
<p>You can't easily escape a loop within the scope of your do-while &quot;loop&quot;. Instead, you'll end up having to add another variable and check to determine if you need to <code>break</code> a second time.</p>
</li>
</ol>
<h2>Exception Handling</h2>
<p>Ha-ha just kidding! 😅 While exception handling is actually available to C programmers on Windows (!), it's not accessible for cross-platform C software development. Call me a snob, but I believe that applications should be written to be as portable as possible.</p>
<h2>The <code>goto done</code></h2>
<p>Finally we get to the <code>goto done</code> method for error handling and resource cleanup. I don't wish to anger the ghost of Edsger Dijkstra so I should warn you that the key to using <code>goto</code> &quot;right&quot; are thus:</p>
<ol>
<li><em>Always</em> go-forwards! <strong>NEVER</strong> go backwards!</li>
<li>Keep it simple! Multiple labels are cool and may help from time to time, like in our example. But 9 times out of 10 you only need one label. Also, I should have to say this but keep your functions at a reasonable size.  They shouldn't be 1-liners but if they get much larger than a page or two, consider refactoring!</li>
</ol>
<p>Here I present to you the example code using the <code>goto</code> method:</p>
<pre style="background-color:#2d2d2d;">
<span style="background-color:#2d2d2d;color:#747369;">/* Standard libs */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;stdbool.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;    </span><span style="background-color:#2d2d2d;color:#747369;">/* For bool */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;stdint.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;     </span><span style="background-color:#2d2d2d;color:#747369;">/* For modern integer types */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;stdlib.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;     </span><span style="background-color:#2d2d2d;color:#747369;">/* For malloc/free */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;string.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;     </span><span style="background-color:#2d2d2d;color:#747369;">/* For strdup */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;stdio.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;      </span><span style="background-color:#2d2d2d;color:#747369;">/* For printf */

/* 3rd-party Libs */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;pthread.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;

</span><span style="background-color:#2d2d2d;color:#cc99cc;">typedef struct </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">char </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* name;
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">void </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* data;
} named_data_t;

</span><span style="background-color:#2d2d2d;color:#747369;">/* We&#39;ll allocate the array of data pointers in increments of 100 */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#define DATA_ARRAY_BLOCK_SIZE </span><span style="background-color:#2d2d2d;color:#f99157;">100

</span><span style="background-color:#2d2d2d;color:#cc99cc;">static </span><span style="background-color:#2d2d2d;color:#d3d0c8;">pthread_mutex_t data_array_lock = PTHREAD_MUTEX_INITIALIZER;
</span><span style="background-color:#2d2d2d;color:#cc99cc;">static</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> named_data_t ** g_data_array = </span><span style="background-color:#2d2d2d;color:#f99157;">NULL</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
</span><span style="background-color:#2d2d2d;color:#cc99cc;">static </span><span style="background-color:#2d2d2d;color:#d3d0c8;">size_t g_data_array_size = </span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">; </span><span style="background-color:#2d2d2d;color:#747369;">/* Size of array (in element) */
</span><span style="background-color:#2d2d2d;color:#cc99cc;">static </span><span style="background-color:#2d2d2d;color:#d3d0c8;">size_t g_num_data_elements = </span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;  </span><span style="background-color:#2d2d2d;color:#747369;">/* Number of element in array */

/**
 * @brief Add a new named data element to the global array.
 *
 * @param name      Element name
 * @param data      Pointer to the element data
 * @return true     Element successfully added.
 * @return false    Failed to add element.
 */
</span><span style="background-color:#2d2d2d;color:#cc99cc;">bool </span><span style="background-color:#2d2d2d;color:#6699cc;">append_data_element</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#cc99cc;">const char </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* name, </span><span style="background-color:#2d2d2d;color:#cc99cc;">void </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* data) {
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">bool</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status = </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    named_data_t *new_element = </span><span style="background-color:#2d2d2d;color:#f99157;">NULL</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== name || </span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== data) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Bad args! */
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> done;
    }

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Allocate a new struct to put on our array. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
    new_element = </span><span style="background-color:#2d2d2d;color:#66cccc;">malloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(sizeof(named_data_t));
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== new_element) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Out of memory! */
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> done;
    }

    </span><span style="background-color:#2d2d2d;color:#747369;">/* We don&#39;t own the name, so let&#39;s duplicate it. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
    new_element-&gt;name = </span><span style="background-color:#2d2d2d;color:#6699cc;">strdup</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(name);
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== new_element-&gt;name) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Out of memory! */
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> done;
    }

    </span><span style="background-color:#2d2d2d;color:#747369;">/* We&#39;re being given ownership of the data, so we&#39;ll just assign the pointer. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
    new_element-&gt;name = data;

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Lock the array so we can safely add our new element. */
    </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_lock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);

    </span><span style="background-color:#2d2d2d;color:#747369;">/*
     * Append our data element to the end of the array.
     */
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== g_data_array) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Array doesn&#39;t exist, let&#39;s allocate it */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">

        g_data_array = </span><span style="background-color:#2d2d2d;color:#66cccc;">malloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(DATA_ARRAY_BLOCK_SIZE * sizeof(named_data_t*));
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== g_data_array) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Failed to allocate memory for data array! */
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> unlock;
        }

        g_data_array_size = DATA_ARRAY_BLOCK_SIZE;

    } </span><span style="background-color:#2d2d2d;color:#cc99cc;">else if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(g_num_data_elements == g_data_array_size) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Array is full, allocate more memory */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
        named_data_t ** temp;

        temp = </span><span style="background-color:#2d2d2d;color:#66cccc;">realloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(g_data_array, (g_data_array_size + DATA_ARRAY_BLOCK_SIZE) * sizeof(named_data_t*));
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== temp) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Failed to increase size of data array! */
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> unlock;
        }
        g_data_array = temp;
        g_data_array_size += DATA_ARRAY_BLOCK_SIZE;
    }

    g_data_array[g_num_data_elements] = new_element;
    g_num_data_elements += </span><span style="background-color:#2d2d2d;color:#f99157;">1</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Success! */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
    status = </span><span style="background-color:#2d2d2d;color:#f99157;">true</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

unlock:
    </span><span style="background-color:#2d2d2d;color:#747369;">/* Unlock the array so other threads can access it once more. */
    </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_unlock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);

done:

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">false </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== status) {
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">!= new_element) {
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">!= new_element-&gt;name) {
                </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element-&gt;name);
            }
            </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element);
        }
    }

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">return</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status;
}
</span></pre>
<p>Another advantage of the <code>goto</code> method is that with <code>goto</code>'s and a common scheme for the label (like <code>done</code>), you can wrap <code>malloc</code>, <code>strdup</code>, <code>realloc</code>, and other functions with macros to try to enforce consistent error handling when allocation functions fail.</p>
<p>Eg:</p>
<pre style="background-color:#2d2d2d;">
<span style="background-color:#2d2d2d;color:#cc99cc;">#define </span><span style="background-color:#2d2d2d;color:#6699cc;">DO_MALLOC</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f2777a;">var</span><span style="background-color:#2d2d2d;color:#d3d0c8;">, </span><span style="background-color:#2d2d2d;color:#f2777a;">size</span><span style="background-color:#2d2d2d;color:#d3d0c8;">) \
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">do </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{                     \
        var = </span><span style="background-color:#2d2d2d;color:#66cccc;">malloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(size);  \
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== var) {   \
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> done;       \
        }                    \
    } </span><span style="background-color:#2d2d2d;color:#cc99cc;">while </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">)
</span></pre>
<p><code>*</code>As a side note, you may have noticed my the use of a <code>do { ... } while (0);</code> there. As it turns out, this confusing-looking contsruct does unfortunately have a place in C programming as a mechanism for writing safe and reliable function-like macros. It is once again a bit of a hack, but it's the best option we have. For more information, have a gander at <a href="https://stackoverflow.com/questions/1067226/c-multi-line-macro-do-while0-vs-scope-block">this explanation on StackOverflow</a>.</p>
<p>So to make use of the macro wrappers in our original example, we have this final variant of our original program:</p>
<pre style="background-color:#2d2d2d;">
<span style="background-color:#2d2d2d;color:#747369;">/* Standard libs */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;stdbool.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;    </span><span style="background-color:#2d2d2d;color:#747369;">/* For bool */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;stdint.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;     </span><span style="background-color:#2d2d2d;color:#747369;">/* For modern integer types */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;stdlib.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;     </span><span style="background-color:#2d2d2d;color:#747369;">/* For malloc/free */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;string.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;     </span><span style="background-color:#2d2d2d;color:#747369;">/* For strdup */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;stdio.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;      </span><span style="background-color:#2d2d2d;color:#747369;">/* For printf */

/* 3rd-party Libs */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;pthread.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;

#define </span><span style="background-color:#2d2d2d;color:#6699cc;">DO_MALLOC</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(var, size)        \
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">do </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{                            \
        var = </span><span style="background-color:#2d2d2d;color:#66cccc;">malloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(size);         \
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== var) {          \
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> done;              \
        }                           \
    } </span><span style="background-color:#2d2d2d;color:#cc99cc;">while </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">)

#define </span><span style="background-color:#2d2d2d;color:#6699cc;">DO_REALLOC</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(var, size)       \
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">do </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{                            \
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">void </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* temp;                \
        temp = </span><span style="background-color:#2d2d2d;color:#66cccc;">realloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(var, size);  \
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== temp) {         \
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> done;              \
        }                           \
        var = temp;                 \
    } </span><span style="background-color:#2d2d2d;color:#cc99cc;">while </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">)

#define </span><span style="background-color:#2d2d2d;color:#6699cc;">DO_STRDUP</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(var, buf)         \
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">do </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{                            \
        var = </span><span style="background-color:#2d2d2d;color:#6699cc;">strdup</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(buf);          \
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== var) {          \
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> done;              \
        }                           \
    } </span><span style="background-color:#2d2d2d;color:#cc99cc;">while </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">)

</span><span style="background-color:#2d2d2d;color:#cc99cc;">typedef struct </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">char </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* name;
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">void </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* data;
} named_data_t;

</span><span style="background-color:#2d2d2d;color:#747369;">/* We&#39;ll allocate the array of data pointers in increments of 100 */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#define DATA_ARRAY_BLOCK_SIZE </span><span style="background-color:#2d2d2d;color:#f99157;">100

</span><span style="background-color:#2d2d2d;color:#cc99cc;">static </span><span style="background-color:#2d2d2d;color:#d3d0c8;">pthread_mutex_t data_array_lock = PTHREAD_MUTEX_INITIALIZER;
</span><span style="background-color:#2d2d2d;color:#cc99cc;">static</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> named_data_t ** g_data_array = </span><span style="background-color:#2d2d2d;color:#f99157;">NULL</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
</span><span style="background-color:#2d2d2d;color:#cc99cc;">static </span><span style="background-color:#2d2d2d;color:#d3d0c8;">size_t g_data_array_size = </span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">; </span><span style="background-color:#2d2d2d;color:#747369;">/* Size of array (in element) */
</span><span style="background-color:#2d2d2d;color:#cc99cc;">static </span><span style="background-color:#2d2d2d;color:#d3d0c8;">size_t g_num_data_elements = </span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;  </span><span style="background-color:#2d2d2d;color:#747369;">/* Number of element in array */

/**
 * @brief Add a new named data element to the global array.
 *
 * @param name      Element name
 * @param data      Pointer to the element data
 * @return true     Element successfully added.
 * @return false    Failed to add element.
 */
</span><span style="background-color:#2d2d2d;color:#cc99cc;">bool </span><span style="background-color:#2d2d2d;color:#6699cc;">append_data_element</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#cc99cc;">const char </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* name, </span><span style="background-color:#2d2d2d;color:#cc99cc;">void </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* data) {
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">bool</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status = </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    named_data_t *new_element = </span><span style="background-color:#2d2d2d;color:#f99157;">NULL</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== name || </span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== data) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Bad args! */
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> done;
    }

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Allocate a new struct to put on our array. */
    </span><span style="background-color:#2d2d2d;color:#6699cc;">DO_MALLOC</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element, sizeof(named_data_t));

    </span><span style="background-color:#2d2d2d;color:#747369;">/* We don&#39;t own the name, so let&#39;s duplicate it. */
    </span><span style="background-color:#2d2d2d;color:#6699cc;">DO_STRDUP</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element-&gt;name, name);

    </span><span style="background-color:#2d2d2d;color:#747369;">/* We&#39;re being given ownership of the data, so we&#39;ll just assign the pointer. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
    new_element-&gt;name = data;

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Lock the array so we can safely add our new element. */
    </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_lock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);

    </span><span style="background-color:#2d2d2d;color:#747369;">/*
     * Append our data element to the end of the array.
     */
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== g_data_array) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Array doesn&#39;t exist, let&#39;s allocate it */

        </span><span style="background-color:#2d2d2d;color:#6699cc;">DO_MALLOC</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(g_data_array, DATA_ARRAY_BLOCK_SIZE * sizeof(named_data_t*));
        g_data_array_size = DATA_ARRAY_BLOCK_SIZE;

    } </span><span style="background-color:#2d2d2d;color:#cc99cc;">else if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(g_num_data_elements == g_data_array_size) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Array is full, allocate more memory */
        </span><span style="background-color:#2d2d2d;color:#6699cc;">DO_REALLOC</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(g_data_array, (g_data_array_size + DATA_ARRAY_BLOCK_SIZE) * sizeof(named_data_t*));
        g_data_array_size += DATA_ARRAY_BLOCK_SIZE;
    }

    g_data_array[g_num_data_elements] = new_element;
    g_num_data_elements += </span><span style="background-color:#2d2d2d;color:#f99157;">1</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Success! */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
    status = </span><span style="background-color:#2d2d2d;color:#f99157;">true</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

unlock:
    </span><span style="background-color:#2d2d2d;color:#747369;">/* Unlock the array so other threads can access it once more. */
    </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_unlock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);

done:

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">false </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== status) {
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">!= new_element) {
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">!= new_element-&gt;name) {
                </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element-&gt;name);
            }
            </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element);
        }
    }

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">return</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status;
}
</span></pre>
<p>To end this piece, I'll leave you with some supporting links for how to safely use goto for error handling, and why perhaps do/while(0) can cause problems (with loops):</p>
<ul>
<li>https://embeddedgurus.com/barr-code/2018/06/cs-goto-keyword-should-we-use-it-or-lose-it/</li>
<li>https://ayende.com/blog/183521-C/error-handling-via-goto-in-c</li>
<li>https://www.cprogramming.com/tutorial/goto.html</li>
<li>https://embeddedgurus.com/stack-overflow/2010/02/goto-heresy/</li>
</ul>
<p>Until next time!</p>
<p>-Micah</p>
<h2><em>12/11/2020</em> - Postscript; The <code>else if</code></h2>
<p>There is one additional error handling pattern that can work quite well in many situations. I call this one the <code>else if</code>.</p>
<p>This pattern works when you're able to construct each line of code as a series of <code>else if</code> statements that test for failure with one final <code>else</code> for the success-condition. Resource cleanup happens <em>after</em> the final <code>else</code> block such that each failure condition and the success condition a followed immediately by resource cleanup.</p>
<p>However, when following this pattern you may at some point need to set a variable in the middle or make some call doesn't chain. This breaks up the <code>else if</code> flow and can complicate your error handling pattern. It may be an indication that you should break up the function into multiple functions but resolving these <code>else if</code> interruptions in an elegant way often requires careful planning.</p>
<p>Here's an attempt to apply the <code>else if</code> error handling pattern to our example program:</p>
<pre style="background-color:#2d2d2d;">
<span style="background-color:#2d2d2d;color:#747369;">/* Standard libs */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;stdbool.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;    </span><span style="background-color:#2d2d2d;color:#747369;">/* For bool */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;stdint.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;     </span><span style="background-color:#2d2d2d;color:#747369;">/* For modern integer types */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;stdlib.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;     </span><span style="background-color:#2d2d2d;color:#747369;">/* For malloc/free */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;string.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;     </span><span style="background-color:#2d2d2d;color:#747369;">/* For strdup */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;stdio.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;      </span><span style="background-color:#2d2d2d;color:#747369;">/* For printf */

/* 3rd-party Libs */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#include &lt;pthread.</span><span style="background-color:#2d2d2d;color:#f2777a;">h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&gt;

</span><span style="background-color:#2d2d2d;color:#cc99cc;">typedef struct </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">char </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* name;
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">void </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* data;
} named_data_t;

</span><span style="background-color:#2d2d2d;color:#747369;">/* We&#39;ll allocate the array of data pointers in increments of 100 */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
#define DATA_ARRAY_BLOCK_SIZE </span><span style="background-color:#2d2d2d;color:#f99157;">100

</span><span style="background-color:#2d2d2d;color:#cc99cc;">static </span><span style="background-color:#2d2d2d;color:#d3d0c8;">pthread_mutex_t data_array_lock = PTHREAD_MUTEX_INITIALIZER;
</span><span style="background-color:#2d2d2d;color:#cc99cc;">static</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> named_data_t ** g_data_array = </span><span style="background-color:#2d2d2d;color:#f99157;">NULL</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
</span><span style="background-color:#2d2d2d;color:#cc99cc;">static </span><span style="background-color:#2d2d2d;color:#d3d0c8;">size_t g_data_array_size = </span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;    </span><span style="background-color:#2d2d2d;color:#747369;">/* Size of array (in element) */
</span><span style="background-color:#2d2d2d;color:#cc99cc;">static </span><span style="background-color:#2d2d2d;color:#d3d0c8;">size_t g_num_data_elements = </span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;  </span><span style="background-color:#2d2d2d;color:#747369;">/* Number of element in array */

</span><span style="background-color:#2d2d2d;color:#cc99cc;">bool </span><span style="background-color:#2d2d2d;color:#6699cc;">allocate_global_data_array_if_needed</span><span style="background-color:#2d2d2d;color:#d3d0c8;">() {
    named_data_t ** temp;

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">((</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== g_data_array) &amp;&amp;
        (</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== (g_data_array = </span><span style="background-color:#2d2d2d;color:#66cccc;">malloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(DATA_ARRAY_BLOCK_SIZE * sizeof(named_data_t*))))) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Failed to allocate memory for data array! */
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">return </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    } </span><span style="background-color:#2d2d2d;color:#cc99cc;">else </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{
        g_data_array_size = DATA_ARRAY_BLOCK_SIZE;
    }

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">((g_num_data_elements == g_data_array_size) &amp;&amp;
        (</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== (temp = </span><span style="background-color:#2d2d2d;color:#66cccc;">realloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(g_data_array, (g_data_array_size + DATA_ARRAY_BLOCK_SIZE) * sizeof(named_data_t*))))) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Array was is full, and we failed to allocate more memory */
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">return </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    } </span><span style="background-color:#2d2d2d;color:#cc99cc;">else </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{
        g_data_array = temp;
        g_data_array_size += DATA_ARRAY_BLOCK_SIZE;
    }

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">return </span><span style="background-color:#2d2d2d;color:#f99157;">true</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
}

</span><span style="background-color:#2d2d2d;color:#cc99cc;">bool </span><span style="background-color:#2d2d2d;color:#6699cc;">add_element</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(named_data_t *new_element) {
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">bool</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status = </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Lock the array so we can safely add our new element. */
    </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_lock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);

    </span><span style="background-color:#2d2d2d;color:#747369;">/*
     * Append our data element to the end of the array.
     */
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">false </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== </span><span style="background-color:#2d2d2d;color:#6699cc;">allocate_global_data_array_if_needed</span><span style="background-color:#2d2d2d;color:#d3d0c8;">()) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Failed to allocate the global data array */
    </span><span style="background-color:#2d2d2d;color:#d3d0c8;">} </span><span style="background-color:#2d2d2d;color:#cc99cc;">else </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{
        </span><span style="background-color:#2d2d2d;color:#747369;">/*
         * Successs
         */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
        g_data_array[g_num_data_elements] = new_element;
        g_num_data_elements += </span><span style="background-color:#2d2d2d;color:#f99157;">1</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

        status = </span><span style="background-color:#2d2d2d;color:#f99157;">true</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    }

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Unlock the array so other threads can access it once more. */
    </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_unlock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">return</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status;
}

</span><span style="background-color:#2d2d2d;color:#747369;">/**
 * @brief Add a new named data element to the global array.
 *
 * @param name      Element name
 * @param data      Pointer to the element data
 * @return true     Element successfully added.
 * @return false    Failed to add element.
 */
</span><span style="background-color:#2d2d2d;color:#cc99cc;">bool </span><span style="background-color:#2d2d2d;color:#6699cc;">append_data_element</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#cc99cc;">const char </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* name, </span><span style="background-color:#2d2d2d;color:#cc99cc;">void </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* data) {
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">bool</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status = </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    named_data_t *new_element = </span><span style="background-color:#2d2d2d;color:#f99157;">NULL</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== name || </span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== data) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Bad args! */
        </span><span style="background-color:#2d2d2d;color:#66cccc;">printf</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&quot;</span><span style="background-color:#2d2d2d;color:#99cc99;">add_named_rectangle: Invalid arguments!</span><span style="background-color:#2d2d2d;color:#66cccc;">\n</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;);
    } </span><span style="background-color:#2d2d2d;color:#cc99cc;">else if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== (new_element = </span><span style="background-color:#2d2d2d;color:#66cccc;">malloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(sizeof(named_data_t)))) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Out of memory! */
    </span><span style="background-color:#2d2d2d;color:#d3d0c8;">} </span><span style="background-color:#2d2d2d;color:#cc99cc;">else if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== (new_element-&gt;name = </span><span style="background-color:#2d2d2d;color:#6699cc;">strdup</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(name))){
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Out of memory! */
    </span><span style="background-color:#2d2d2d;color:#d3d0c8;">} </span><span style="background-color:#2d2d2d;color:#cc99cc;">else </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{
        </span><span style="background-color:#2d2d2d;color:#747369;">/* We&#39;re being given ownership of the data, so we&#39;ll just assign the pointer. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
        new_element-&gt;name = data;

        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">false </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== </span><span style="background-color:#2d2d2d;color:#6699cc;">add_element</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element)) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Failed to add element */
        </span><span style="background-color:#2d2d2d;color:#d3d0c8;">} </span><span style="background-color:#2d2d2d;color:#cc99cc;">else </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{
            </span><span style="background-color:#2d2d2d;color:#747369;">/*
             * Successs
             */
            </span><span style="background-color:#2d2d2d;color:#66cccc;">printf</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&quot;</span><span style="background-color:#2d2d2d;color:#99cc99;">add_named_rectangle: Added &#39;</span><span style="background-color:#2d2d2d;color:#f99157;">%s</span><span style="background-color:#2d2d2d;color:#99cc99;">&#39; element to data array!</span><span style="background-color:#2d2d2d;color:#66cccc;">\n</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;, name);
        }
    }

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Clean up, as needed */
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">false </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== status) {
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">!= new_element) {
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">!= new_element-&gt;name) {
                </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element-&gt;name);
            }
            </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element);
        }
    }

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">return</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status;
}

</span><span style="background-color:#2d2d2d;color:#cc99cc;">int </span><span style="background-color:#2d2d2d;color:#6699cc;">main</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#cc99cc;">void</span><span style="background-color:#2d2d2d;color:#d3d0c8;">) {
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">true </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== </span><span style="background-color:#2d2d2d;color:#6699cc;">append_data_element</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&quot;</span><span style="background-color:#2d2d2d;color:#99cc99;">Hello</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;, (</span><span style="background-color:#2d2d2d;color:#cc99cc;">void </span><span style="background-color:#2d2d2d;color:#d3d0c8;">*)&quot;</span><span style="background-color:#2d2d2d;color:#99cc99;">World</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;)) {
        </span><span style="background-color:#2d2d2d;color:#66cccc;">printf</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&quot;</span><span style="background-color:#2d2d2d;color:#99cc99;">Added element to array</span><span style="background-color:#2d2d2d;color:#66cccc;">\n</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;);
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">return </span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    }
    </span><span style="background-color:#2d2d2d;color:#66cccc;">printf</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&quot;</span><span style="background-color:#2d2d2d;color:#99cc99;">Failed to add element to array</span><span style="background-color:#2d2d2d;color:#66cccc;">\n</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;);
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">return </span><span style="background-color:#2d2d2d;color:#f99157;">1</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
}
</span></pre>
<p>The <code>else if</code> pattern is works out ok for a few calls in but it breaks down a bit when you need to set variables or make standalone calls like our call to lock &amp; unlock the mutex, or to allocate memory for the global data array if needed.</p>
<p>With some careful planning and well structured functions, this pattern can be quite effective, but it does take a surprising amount of effort.</p>
<p>I used to like the <code>else if</code> pattern quite a bit. Nowadays, the <code>goto done</code> pattern is my error handling method of choice. The <code>goto done</code> pattern is easier to read, write, and maintain.</p>

      <footer>
        <footer>
  <hr>
  <p>
    <center>
      Copyright © 2020 Micah Snyder
      |
      <a href="https://twitter.com/0xC0000063"><img src="https://abs.twimg.com/favicons/twitter.ico" width="20" height="20"></a>
      <a href="https://github.com/micahsnyder"><img src="https://github.githubassets.com/favicons/favicon-dark.png" width="20" height="20"></a>
      <a href="https://gitlab.com/micahsnyder"><img src="https://gitlab.com/assets/favicon-7901bd695fb93edb07975966062049829afb56cf11511236e61bcf425070e36e.png" width="20" height="20"></a>
    </center>
  </p>
  <br>
</footer>
      </footer>
    </div>
    <div class="rightDiv">
      <h3>Posts</h3>
      
        <p>
          &nbsp;&nbsp;<a href=https://blog.micahsnyder.dev/posts/2020-12-11-02-error-handling-in-c.html>Error Handling in C</a>
        </p>
      
        <p>
          &nbsp;&nbsp;<a href=https://blog.micahsnyder.dev/posts/2020-12-11-01-introduction.html>Introduction</a>
        </p>
      
    </div>
    <div "style: clear:both;"></div>
  </div>
</body>

</html>
