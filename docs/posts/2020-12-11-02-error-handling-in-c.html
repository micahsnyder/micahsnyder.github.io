<!DOCTYPE html>
<html>

<head>
  
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Error Handling in C</title>
<link href='https://fonts.googleapis.com/css?family=Muli:400,300' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Lobster%20Two:400,300' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Fira%20Code:400,300' rel='stylesheet' type='text/css'>
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha256-3dkvEK0WLHRJ7/Csr0BZjAWxERc5WH7bdeUya2aXxdU= sha512-+L4yy6FRcDGbXJ9mPG8MT/3UCDzwR9gPeyFNMCtInsol++5m3bk2bXWKdZjvybmohrAsn3Ua5x8gfLnbE1YkOg==" crossorigin="anonymous">
<link rel="stylesheet" href="/writ.min.css">
<link rel="stylesheet" href="/style.css" type="text/css" media="all" />
<link rel="alternate" href="/rss.xml" type="application/rss+xml" title="RSS" />

</head>

<body>
  <header>
    <header>
   <h2>Micah Snyder's blog</h2>
</header>
  </header>

  <div class="outerDiv">
    <div class="leftDiv">
      <h1>Error Handling in C</h1>
<p>2020-12-11 07:32:15 +0000</p>
<hr />
<p>It is far too easy for C code to spring memory leaks due to shoddy error handling. In a larger code base poor error handling habits can result in years of agony tracking down bugs and digging out from small mountain of technical debt.</p>
<p>No thanks to Edsger Dijkstra's infamous 1968 letter &quot;Go To Statement Considered Harmful&quot;, just about every C programmer has been told at one time that <code>goto</code> is &quot;bad&quot;. This still rings true except for one use of <code>goto</code>: error handling.</p>
<p>In this article I'll present an overview of a few different error handling methods available to the C programmer. To illustrate, I've crated example multi-threaded application that stores named data-elements in a global growable array protected by a mutex. The function in our example adds one element to the array, and allocates more space for the array as needed.</p>
<p>By the end of this article, I hope you'll agree with me on the best option for error handling in C (<em>hint</em>: it's <code>goto</code>).</p>
<p><em>Nota bene</em>: The following code samples are snippets. You can find the full source in the blog git repository under the <a href="https://github.com/micahsnyder/micahsnyder.github.io/tree/master/sample_code">sample_code</a> directory.</p>
<h2>The &quot;Multiple Return&quot; pattern</h2>
<p>Perhaps the most common method for error handling, especially in older C code involves the use of multiple <code>return</code> statements. Allocated memory, thread locks, and other resources are cleaned up as-needed at each <code>return</code>.</p>
<p>Without further ado, here's our first variant of the example program featuring the &quot;Multiple <code>return</code>s&quot; error handling method:</p>
<pre style="background-color:#2d2d2d;">
<span style="background-color:#2d2d2d;color:#cc99cc;">#include </span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;</span><span style="background-color:#2d2d2d;color:#99cc99;">sample_test.h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;

</span><span style="background-color:#2d2d2d;color:#747369;">/**
 * @brief Add a new named data element to the global array.
 *
 * @param name      Element name
 * @param data      Pointer to the element data
 * @return true     Element successfully added.
 * @return false    Failed to add element.
 */
</span><span style="background-color:#2d2d2d;color:#cc99cc;">bool </span><span style="background-color:#2d2d2d;color:#6699cc;">append_data_element</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#cc99cc;">const char </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* name, </span><span style="background-color:#2d2d2d;color:#cc99cc;">void </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* data) {
    named_data_t *new_element = </span><span style="background-color:#2d2d2d;color:#f99157;">NULL</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== name || </span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== data) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Bad args! */
        </span><span style="background-color:#2d2d2d;color:#66cccc;">printf</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&quot;</span><span style="background-color:#2d2d2d;color:#99cc99;">add_named_rectangle: Invalid arguments!</span><span style="background-color:#2d2d2d;color:#66cccc;">\n</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;);
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">return </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    }

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Allocate a new struct to put on our array. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
    new_element = </span><span style="background-color:#2d2d2d;color:#66cccc;">malloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(sizeof(named_data_t));
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== new_element) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Out of memory! */
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">return </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    }

    </span><span style="background-color:#2d2d2d;color:#747369;">/* We don&#39;t own the name, so let&#39;s duplicate it. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
    new_element-&gt;name = </span><span style="background-color:#2d2d2d;color:#6699cc;">strdup</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(name);
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== new_element-&gt;name) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Out of memory! */
        </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element);
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">return </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    }

    </span><span style="background-color:#2d2d2d;color:#747369;">/* We&#39;re given ownership of the data, so we&#39;ll assign the pointer. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
    new_element-&gt;data = data;

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Lock the array so we can safely add our new element. */
    </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_lock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);

    </span><span style="background-color:#2d2d2d;color:#747369;">/*
     * Append our data element to the end of the array.
     */
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== g_data_array) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Array doesn&#39;t exist, let&#39;s allocate it */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">

        g_data_array = </span><span style="background-color:#2d2d2d;color:#66cccc;">malloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(ARRAY_BLK_SZ * sizeof(named_data_t*));
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== g_data_array) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Failed to allocate memory for data array! */
            </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_unlock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);
            </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element-&gt;name);
            </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element);
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">return </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
        }

        g_data_array_size = ARRAY_BLK_SZ;

    } </span><span style="background-color:#2d2d2d;color:#cc99cc;">else if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(g_num_data_elements == g_data_array_size) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Array is full, allocate more memory */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
        named_data_t ** temp;

        temp = </span><span style="background-color:#2d2d2d;color:#66cccc;">realloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(
            g_data_array,
            (g_data_array_size + ARRAY_BLK_SZ) * sizeof(named_data_t*));
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== temp) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Failed to increase size of data array! */
            </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_unlock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);
            </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element-&gt;name);
            </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element);
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">return </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
        }

        g_data_array = temp;
        g_data_array_size += ARRAY_BLK_SZ;
    }

    g_data_array[g_num_data_elements] = new_element;
    g_num_data_elements += </span><span style="background-color:#2d2d2d;color:#f99157;">1</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Unlock the array so other threads can access it once more. */
    </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_unlock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);

    </span><span style="background-color:#2d2d2d;color:#66cccc;">printf</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&quot;</span><span style="background-color:#2d2d2d;color:#99cc99;">add_named_rectangle: Added &#39;</span><span style="background-color:#2d2d2d;color:#f99157;">%s</span><span style="background-color:#2d2d2d;color:#99cc99;">&#39; element to array!</span><span style="background-color:#2d2d2d;color:#66cccc;">\n</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;, name);

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">return </span><span style="background-color:#2d2d2d;color:#f99157;">true</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
}
</span></pre>
<p>As you review the above example, note how much duplicate code exists for resource cleanup during error handling. Can you see how easy it would be to forget to clean up a malloced pointer or a locked mutex. This is a recipe for disaster!</p>
<h2>The &quot;do - while(0)&quot; pattern</h2>
<p>Another surprisingly popular option for error handling in C is to wrap all function code in a big ol' <code>while</code> &quot;loop&quot; that doesn't actually loop.</p>
<p>I'm not a big fan of the &quot;do - while(0)&quot; approach to error handling for a few reasons...</p>
<p>First and foremost, it's an obvious hack to perform a <code>goto</code> without using the word <code>goto</code>!</p>
<p>Secondly, it's confusing. To the novice programmer, this approach for error handling is non-obvious because it abuses the do-while looping construct to perform a completely different task. An experienced programmer may appreciate such cleverness but the simple fact is that code which is hard to read is hard to maintain and increases the barrier to entry for novice programmers with little if any real benefit.</p>
<p>Additionally, I think the extra indentation of the &quot;do - while(0)&quot; is harder to read.</p>
<p>Here's our example using the do-while method:</p>
<pre style="background-color:#2d2d2d;">
<span style="background-color:#2d2d2d;color:#cc99cc;">#include </span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;</span><span style="background-color:#2d2d2d;color:#99cc99;">sample_test.h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;

</span><span style="background-color:#2d2d2d;color:#747369;">/**
 * @brief Add a new named data element to the global array.
 *
 * @param name      Element name
 * @param data      Pointer to the element data
 * @return true     Element successfully added.
 * @return false    Failed to add element.
 */
</span><span style="background-color:#2d2d2d;color:#cc99cc;">bool </span><span style="background-color:#2d2d2d;color:#6699cc;">append_data_element</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#cc99cc;">const char </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* name, </span><span style="background-color:#2d2d2d;color:#cc99cc;">void </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* data) {
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">bool</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status = </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    named_data_t *new_element = </span><span style="background-color:#2d2d2d;color:#f99157;">NULL</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">do </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== name || </span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== data) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Bad args! */
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">break</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
        }

        </span><span style="background-color:#2d2d2d;color:#747369;">/* Allocate a new struct to put on our array. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
        new_element = </span><span style="background-color:#2d2d2d;color:#66cccc;">malloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(sizeof(named_data_t));
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== new_element) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Out of memory! */
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">break</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
        }

        </span><span style="background-color:#2d2d2d;color:#747369;">/* We don&#39;t own the name, so let&#39;s duplicate it. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
        new_element-&gt;name = </span><span style="background-color:#2d2d2d;color:#6699cc;">strdup</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(name);
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== new_element-&gt;name) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Out of memory! */
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">break</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
        }

        </span><span style="background-color:#2d2d2d;color:#747369;">/* We&#39;re given ownership of the data, so we&#39;ll assign the pointer. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
        new_element-&gt;data = data;

        </span><span style="background-color:#2d2d2d;color:#747369;">/* Lock the array so we can safely add our new element. */
        </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_lock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);

        </span><span style="background-color:#2d2d2d;color:#747369;">/*
         * Append our data element to the end of the array.
         */
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== g_data_array) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Array doesn&#39;t exist, let&#39;s allocate it */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">

            g_data_array = </span><span style="background-color:#2d2d2d;color:#66cccc;">malloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(ARRAY_BLK_SZ * sizeof(named_data_t*));
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== g_data_array) {
                </span><span style="background-color:#2d2d2d;color:#747369;">/* Failed to allocate memory for data array! */
                /* !! We still have to unlock the mutex before we break */
                </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_unlock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);
                </span><span style="background-color:#2d2d2d;color:#cc99cc;">break</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
            }

            g_data_array_size = ARRAY_BLK_SZ;

        } </span><span style="background-color:#2d2d2d;color:#cc99cc;">else if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(g_num_data_elements == g_data_array_size) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Array is full, allocate more memory */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
            named_data_t ** temp;

            temp = </span><span style="background-color:#2d2d2d;color:#66cccc;">realloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(
                g_data_array,
                (g_data_array_size + ARRAY_BLK_SZ) * sizeof(named_data_t*));
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== temp) {
                </span><span style="background-color:#2d2d2d;color:#747369;">/* Failed to increase size of data array! */
                /* !! We still have to unlock the mutex before we break */
                </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_unlock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);
                </span><span style="background-color:#2d2d2d;color:#cc99cc;">break</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
            }
            g_data_array = temp;
            g_data_array_size += ARRAY_BLK_SZ;
        }

        g_data_array[g_num_data_elements] = new_element;
        g_num_data_elements += </span><span style="background-color:#2d2d2d;color:#f99157;">1</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

        </span><span style="background-color:#2d2d2d;color:#747369;">/* Unlock the array so other threads can access it once more. */
        </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_unlock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);

        </span><span style="background-color:#2d2d2d;color:#747369;">/* Success! */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
        status = </span><span style="background-color:#2d2d2d;color:#f99157;">true</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    } </span><span style="background-color:#2d2d2d;color:#cc99cc;">while</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">);

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">false </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== status) {
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">!= new_element) {
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">!= new_element-&gt;name) {
                </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element-&gt;name);
            }
            </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element);
        }
    }

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">return</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status;
}
</span></pre>
<p>But the real reason this method is bad is that it isn't as flexible as using <code>goto</code> for error handling. Here are a couple ways in which the do-while approach to error-handling and resource cleanup breaks down:</p>
<ol>
<li>
<p>You can't have multiple exit points. With the <code>goto</code>, you can have more than one label if you have different ways of cleaning up. In the do-while example above, you'll see that a lack of multiple labels mean we still have to unlock the mutex before our <code>break</code> as there's no way to check if we'd locked the mutex without adding an extra variable.</p>
</li>
<li>
<p>You can't easily escape a loop within the scope of your do-while &quot;loop&quot;. Instead, you'll end up having to add another variable and check to determine if you need to <code>break</code> a second time.</p>
</li>
</ol>
<h2>Exception Handling</h2>
<p>Ha-ha just kidding! üòÖ While exception handling is actually available to C programmers on Windows (‚ùï), it's not accessible for cross-platform C software development and so is not something I'm going to spend any time on.</p>
<h2>The &quot;goto done&quot; pattern</h2>
<p>Finally we get to the &quot;goto done&quot; method for error handling and resource cleanup. I don't wish to anger the ghost of Edsger Dijkstra so I should warn you that the key to using <code>goto</code> &quot;right&quot; are thus:</p>
<ol>
<li><em>Always</em> go forwards! <strong>NEVER</strong> go backwards!</li>
<li>Keep it simple! Multiple labels are cool and may help from time to time, like in our example. But 9 times out of 10 you only need one label. Also, I should have to say this but keep your functions at a reasonable size.  They shouldn't be 1-liners but if they get much larger than a page or two, consider refactoring!</li>
</ol>
<p>Here I present to you the example code using the &quot;goto done&quot; method:</p>
<pre style="background-color:#2d2d2d;">
<span style="background-color:#2d2d2d;color:#cc99cc;">#include </span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;</span><span style="background-color:#2d2d2d;color:#99cc99;">sample_test.h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;

</span><span style="background-color:#2d2d2d;color:#747369;">/**
 * @brief Add a new named data element to the global array.
 *
 * @param name      Element name
 * @param data      Pointer to the element data
 * @return true     Element successfully added.
 * @return false    Failed to add element.
 */
</span><span style="background-color:#2d2d2d;color:#cc99cc;">bool </span><span style="background-color:#2d2d2d;color:#6699cc;">append_data_element</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#cc99cc;">const char </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* name, </span><span style="background-color:#2d2d2d;color:#cc99cc;">void </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* data) {
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">bool</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status = </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    named_data_t *new_element = </span><span style="background-color:#2d2d2d;color:#f99157;">NULL</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== name || </span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== data) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Bad args! */
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> done;
    }

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Allocate a new struct to put on our array. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
    new_element = </span><span style="background-color:#2d2d2d;color:#66cccc;">malloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(sizeof(named_data_t));
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== new_element) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Out of memory! */
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> done;
    }

    </span><span style="background-color:#2d2d2d;color:#747369;">/* We don&#39;t own the name, so let&#39;s duplicate it. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
    new_element-&gt;name = </span><span style="background-color:#2d2d2d;color:#6699cc;">strdup</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(name);
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== new_element-&gt;name) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Out of memory! */
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> done;
    }

    </span><span style="background-color:#2d2d2d;color:#747369;">/* We&#39;re given ownership of the data, so we&#39;ll assign the pointer. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
    new_element-&gt;data = data;

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Lock the array so we can safely add our new element. */
    </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_lock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);

    </span><span style="background-color:#2d2d2d;color:#747369;">/*
     * Append our data element to the end of the array.
     */
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== g_data_array) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Array doesn&#39;t exist, let&#39;s allocate it */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">

        g_data_array = </span><span style="background-color:#2d2d2d;color:#66cccc;">malloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(ARRAY_BLK_SZ * sizeof(named_data_t*));
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== g_data_array) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Failed to allocate memory for data array! */
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> unlock;
        }

        g_data_array_size = ARRAY_BLK_SZ;

    } </span><span style="background-color:#2d2d2d;color:#cc99cc;">else if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(g_num_data_elements == g_data_array_size) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Array is full, allocate more memory */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
        named_data_t ** temp;

        temp = </span><span style="background-color:#2d2d2d;color:#66cccc;">realloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(
            g_data_array,
            (g_data_array_size + ARRAY_BLK_SZ) * sizeof(named_data_t*));
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== temp) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Failed to increase size of data array! */
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> unlock;
        }
        g_data_array = temp;
        g_data_array_size += ARRAY_BLK_SZ;
    }

    g_data_array[g_num_data_elements] = new_element;
    g_num_data_elements += </span><span style="background-color:#2d2d2d;color:#f99157;">1</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Success! */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
    status = </span><span style="background-color:#2d2d2d;color:#f99157;">true</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

unlock:
    </span><span style="background-color:#2d2d2d;color:#747369;">/* Unlock the array so other threads can access it once more. */
    </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_unlock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);

done:

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">false </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== status) {
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">!= new_element) {
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">!= new_element-&gt;name) {
                </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element-&gt;name);
            }
            </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element);
        }
    }

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">return</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status;
}
</span></pre>
<p>Another advantage of the <code>goto</code> method is that with <code>goto</code>'s and a common scheme for the label (like <code>done</code>), you can wrap <code>malloc</code>, <code>strdup</code>, <code>realloc</code>, and other functions with macros to try to enforce consistent error handling when allocation functions fail.</p>
<p>Eg:</p>
<pre style="background-color:#2d2d2d;">
<span style="background-color:#2d2d2d;color:#cc99cc;">#define </span><span style="background-color:#2d2d2d;color:#6699cc;">MALLOC_OR_GOTO</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f2777a;">var</span><span style="background-color:#2d2d2d;color:#d3d0c8;">, </span><span style="background-color:#2d2d2d;color:#f2777a;">size</span><span style="background-color:#2d2d2d;color:#d3d0c8;">, </span><span style="background-color:#2d2d2d;color:#f2777a;">label</span><span style="background-color:#2d2d2d;color:#d3d0c8;">)  \
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">do </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{                                  \
        var = </span><span style="background-color:#2d2d2d;color:#66cccc;">malloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(size);               \
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== var) {                \
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> label;                   \
        }                                 \
    } </span><span style="background-color:#2d2d2d;color:#cc99cc;">while </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">)
</span></pre>
<p><code>*</code>As a side note, you may have noticed my the use of a <code>do { ... } while(0)</code> in the above macro. As it turns out, this confusing contsruct does unfortunately have a place in C programming as a mechanism for writing safe and reliable function-like macros. It is once again a bit of a hack, but it's the best option we have. For more information, have a gander at <a href="https://stackoverflow.com/questions/1067226/c-multi-line-macro-do-while0-vs-scope-block">this explanation on StackOverflow</a>.</p>
<p>To make use of the macro wrappers in our original example, we have this final variant of our original program:</p>
<pre style="background-color:#2d2d2d;">
<span style="background-color:#2d2d2d;color:#cc99cc;">#include </span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;</span><span style="background-color:#2d2d2d;color:#99cc99;">sample_test.h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;

#define </span><span style="background-color:#2d2d2d;color:#6699cc;">MALLOC_OR_GOTO</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(var, size, label)  \
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">do </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{                                  \
        var = </span><span style="background-color:#2d2d2d;color:#66cccc;">malloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(size);               \
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== var) {                \
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> label;                   \
        }                                 \
    } </span><span style="background-color:#2d2d2d;color:#cc99cc;">while </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">)

#define </span><span style="background-color:#2d2d2d;color:#6699cc;">REALLOC_OR_GOTO</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(var, size, label) \
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">do </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{                                  \
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">void </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* temp;                      \
        temp = </span><span style="background-color:#2d2d2d;color:#66cccc;">realloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(var, size);        \
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== temp) {               \
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> label;                   \
        }                                 \
        var = temp;                       \
    } </span><span style="background-color:#2d2d2d;color:#cc99cc;">while </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">)

#define </span><span style="background-color:#2d2d2d;color:#6699cc;">STRDUP_OR_GOTO</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(var, buf, label)   \
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">do </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{                                  \
        var = </span><span style="background-color:#2d2d2d;color:#6699cc;">strdup</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(buf);                \
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== var) {                \
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> label;                   \
        }                                 \
    } </span><span style="background-color:#2d2d2d;color:#cc99cc;">while </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">0</span><span style="background-color:#2d2d2d;color:#d3d0c8;">)

</span><span style="background-color:#2d2d2d;color:#747369;">/**
 * @brief Add a new named data element to the global array.
 *
 * @param name      Element name
 * @param data      Pointer to the element data
 * @return true     Element successfully added.
 * @return false    Failed to add element.
 */
</span><span style="background-color:#2d2d2d;color:#cc99cc;">bool </span><span style="background-color:#2d2d2d;color:#6699cc;">append_data_element</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#cc99cc;">const char </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* name, </span><span style="background-color:#2d2d2d;color:#cc99cc;">void </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* data) {
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">bool</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status = </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    named_data_t *new_element = </span><span style="background-color:#2d2d2d;color:#f99157;">NULL</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== name || </span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== data) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Bad args! */
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> done;
    }

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Allocate a new struct to put on our array. */
    </span><span style="background-color:#2d2d2d;color:#6699cc;">MALLOC_OR_GOTO</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element, sizeof(named_data_t), done);

    </span><span style="background-color:#2d2d2d;color:#747369;">/* We don&#39;t own the name, so let&#39;s duplicate it. */
    </span><span style="background-color:#2d2d2d;color:#6699cc;">STRDUP_OR_GOTO</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element-&gt;name, name, done);

    </span><span style="background-color:#2d2d2d;color:#747369;">/* We&#39;re given ownership of the data, so we&#39;ll assign the pointer. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
    new_element-&gt;data = data;

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Lock the array so we can safely add our new element. */
    </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_lock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);

    </span><span style="background-color:#2d2d2d;color:#747369;">/*
     * Append our data element to the end of the array.
     */
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== g_data_array) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Array doesn&#39;t exist, let&#39;s allocate it */

        </span><span style="background-color:#2d2d2d;color:#6699cc;">MALLOC_OR_GOTO</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(
            g_data_array,
            ARRAY_BLK_SZ * sizeof(named_data_t*),
            unlock);
        g_data_array_size = ARRAY_BLK_SZ;

    } </span><span style="background-color:#2d2d2d;color:#cc99cc;">else if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(g_num_data_elements == g_data_array_size) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Array is full, allocate more memory */
        </span><span style="background-color:#2d2d2d;color:#6699cc;">REALLOC_OR_GOTO</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(
            g_data_array,
            (g_data_array_size + ARRAY_BLK_SZ) * sizeof(named_data_t*),
            unlock);
        g_data_array_size += ARRAY_BLK_SZ;
    }

    g_data_array[g_num_data_elements] = new_element;
    g_num_data_elements += </span><span style="background-color:#2d2d2d;color:#f99157;">1</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Success! */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
    status = </span><span style="background-color:#2d2d2d;color:#f99157;">true</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

unlock:
    </span><span style="background-color:#2d2d2d;color:#747369;">/* Unlock the array so other threads can access it once more. */
    </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_unlock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);

done:

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">false </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== status) {
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">!= new_element) {
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">!= new_element-&gt;name) {
                </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element-&gt;name);
            }
            </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element);
        }
    }

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">return</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status;
}
</span></pre>
<p>To end this piece, I'll leave you with some supporting links for how to safely use goto for error handling, and why perhaps do/while(0) can cause problems (with loops):</p>
<ul>
<li><a href="https://embeddedgurus.com/barr-code/2018/06/cs-goto-keyword-should-we-use-it-or-lose-it/">https://embeddedgurus.com/barr-code/2018/06/cs-goto-keyword-should-we-use-it-or-lose-it/</a></li>
<li><a href="https://ayende.com/blog/183521-C/error-handling-via-goto-in-c">https://ayende.com/blog/183521-C/error-handling-via-goto-in-c</a></li>
<li><a href="https://www.cprogramming.com/tutorial/goto.html">https://www.cprogramming.com/tutorial/goto.html</a></li>
<li><a href="https://embeddedgurus.com/stack-overflow/2010/02/goto-heresy/">https://embeddedgurus.com/stack-overflow/2010/02/goto-heresy/</a></li>
</ul>
<p>Until next time!</p>
<p>-Micah</p>
<h2><em>12/11/2020</em> - Postscript; The &quot;else if&quot; pattern</h2>
<p>There is one additional error handling pattern that can work quite well in many situations. I call this one the &quot;else if&quot;.</p>
<p>This pattern works when you're able to construct each line of code as a series of <code>else if</code> statements that test for failure with one final <code>else</code> for the success-condition. Resource cleanup happens <em>after</em> the final <code>else</code> block such that each failure condition and the success condition a followed immediately by resource cleanup.</p>
<p>However, when following this pattern you may at some point need to set a variable in the middle or make some call doesn't chain. This breaks up the &quot;else if&quot;-flow and can complicate your error handling pattern. It may be an indication that you should break up the function into multiple functions but resolving these &quot;else if&quot;-interruptions in an elegant way often requires careful planning.</p>
<p>Here's an attempt to apply the &quot;else if&quot; error handling pattern to our example program:</p>
<pre style="background-color:#2d2d2d;">
<span style="background-color:#2d2d2d;color:#cc99cc;">#include </span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;</span><span style="background-color:#2d2d2d;color:#99cc99;">sample_test.h</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;

</span><span style="background-color:#2d2d2d;color:#cc99cc;">bool </span><span style="background-color:#2d2d2d;color:#6699cc;">allocate_global_data_array_if_needed</span><span style="background-color:#2d2d2d;color:#d3d0c8;">() {
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">bool</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status = </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== g_data_array) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Array is not yet allocated */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
        g_data_array = </span><span style="background-color:#2d2d2d;color:#66cccc;">malloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(ARRAY_BLK_SZ * sizeof(named_data_t*));
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== g_data_array) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Failed to allocate memory for data array! */
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> done;
        }
        g_data_array_size = ARRAY_BLK_SZ;
    }

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(g_num_data_elements == g_data_array_size) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Array is full, attempt to grow the array */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
        named_data_t ** temp;
        temp = </span><span style="background-color:#2d2d2d;color:#66cccc;">realloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(
            g_data_array,
            (g_data_array_size + ARRAY_BLK_SZ) * sizeof(named_data_t*));
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== temp) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Array was is full, and we failed to allocate more memory */
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">goto</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> done;
        }
        g_data_array = temp;
        g_data_array_size += ARRAY_BLK_SZ;
    }

    status = </span><span style="background-color:#2d2d2d;color:#f99157;">true</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

done:
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">return</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status;
}

</span><span style="background-color:#2d2d2d;color:#cc99cc;">bool </span><span style="background-color:#2d2d2d;color:#6699cc;">add_element</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(named_data_t *new_element) {
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">bool</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status = </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Lock the array so we can safely add our new element. */
    </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_lock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);

    </span><span style="background-color:#2d2d2d;color:#747369;">/*
     * Append our data element to the end of the array.
     */
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">false </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== </span><span style="background-color:#2d2d2d;color:#6699cc;">allocate_global_data_array_if_needed</span><span style="background-color:#2d2d2d;color:#d3d0c8;">()) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Failed to allocate the global data array */
    </span><span style="background-color:#2d2d2d;color:#d3d0c8;">} </span><span style="background-color:#2d2d2d;color:#cc99cc;">else </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{
        </span><span style="background-color:#2d2d2d;color:#747369;">/*
         * Successs
         */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
        g_data_array[g_num_data_elements] = new_element;
        g_num_data_elements += </span><span style="background-color:#2d2d2d;color:#f99157;">1</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

        status = </span><span style="background-color:#2d2d2d;color:#f99157;">true</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    }

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Unlock the array so other threads can access it once more. */
    </span><span style="background-color:#2d2d2d;color:#6699cc;">pthread_mutex_unlock</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&amp;data_array_lock);

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">return</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status;
}

</span><span style="background-color:#2d2d2d;color:#747369;">/**
 * @brief Add a new named data element to the global array.
 *
 * @param name      Element name
 * @param data      Pointer to the element data
 * @return true     Element successfully added.
 * @return false    Failed to add element.
 */
</span><span style="background-color:#2d2d2d;color:#cc99cc;">bool </span><span style="background-color:#2d2d2d;color:#6699cc;">append_data_element</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#cc99cc;">const char </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* name, </span><span style="background-color:#2d2d2d;color:#cc99cc;">void </span><span style="background-color:#2d2d2d;color:#d3d0c8;">* data) {
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">bool</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status = </span><span style="background-color:#2d2d2d;color:#f99157;">false</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
    named_data_t *new_element = </span><span style="background-color:#2d2d2d;color:#f99157;">NULL</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== name || </span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== data) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Bad args! */
        </span><span style="background-color:#2d2d2d;color:#66cccc;">printf</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&quot;</span><span style="background-color:#2d2d2d;color:#99cc99;">add_named_rectangle: Invalid arguments!</span><span style="background-color:#2d2d2d;color:#66cccc;">\n</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;);
    } </span><span style="background-color:#2d2d2d;color:#cc99cc;">else if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== (new_element = </span><span style="background-color:#2d2d2d;color:#66cccc;">malloc</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(sizeof(named_data_t)))) {
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Out of memory! */
    </span><span style="background-color:#2d2d2d;color:#d3d0c8;">} </span><span style="background-color:#2d2d2d;color:#cc99cc;">else if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== (new_element-&gt;name = </span><span style="background-color:#2d2d2d;color:#6699cc;">strdup</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(name))){
        </span><span style="background-color:#2d2d2d;color:#747369;">/* Out of memory! */
    </span><span style="background-color:#2d2d2d;color:#d3d0c8;">} </span><span style="background-color:#2d2d2d;color:#cc99cc;">else </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{
        </span><span style="background-color:#2d2d2d;color:#747369;">/* We&#39;re given ownership of the data, so we&#39;ll assign the pointer. */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
        new_element-&gt;data = data;

        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">false </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== </span><span style="background-color:#2d2d2d;color:#6699cc;">add_element</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element)) {
            </span><span style="background-color:#2d2d2d;color:#747369;">/* Failed to add element */
        </span><span style="background-color:#2d2d2d;color:#d3d0c8;">} </span><span style="background-color:#2d2d2d;color:#cc99cc;">else </span><span style="background-color:#2d2d2d;color:#d3d0c8;">{
            </span><span style="background-color:#2d2d2d;color:#747369;">/*
             * Successs
             */</span><span style="background-color:#2d2d2d;color:#d3d0c8;">
            status = </span><span style="background-color:#2d2d2d;color:#f99157;">true</span><span style="background-color:#2d2d2d;color:#d3d0c8;">;
            </span><span style="background-color:#2d2d2d;color:#66cccc;">printf</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(&quot;</span><span style="background-color:#2d2d2d;color:#99cc99;">add_named_rectangle: Added &#39;</span><span style="background-color:#2d2d2d;color:#f99157;">%s</span><span style="background-color:#2d2d2d;color:#99cc99;">&#39; element to array!</span><span style="background-color:#2d2d2d;color:#66cccc;">\n</span><span style="background-color:#2d2d2d;color:#d3d0c8;">&quot;, name);
        }
    }

    </span><span style="background-color:#2d2d2d;color:#747369;">/* Clean up, as needed */
    </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">false </span><span style="background-color:#2d2d2d;color:#d3d0c8;">== status) {
        </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">!= new_element) {
            </span><span style="background-color:#2d2d2d;color:#cc99cc;">if </span><span style="background-color:#2d2d2d;color:#d3d0c8;">(</span><span style="background-color:#2d2d2d;color:#f99157;">NULL </span><span style="background-color:#2d2d2d;color:#d3d0c8;">!= new_element-&gt;name) {
                </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element-&gt;name);
            }
            </span><span style="background-color:#2d2d2d;color:#66cccc;">free</span><span style="background-color:#2d2d2d;color:#d3d0c8;">(new_element);
        }
    }

    </span><span style="background-color:#2d2d2d;color:#cc99cc;">return</span><span style="background-color:#2d2d2d;color:#d3d0c8;"> status;
}
</span></pre>
<p>The &quot;else if&quot; pattern works out ok for a few calls in but it breaks down a bit when I needed to set variables and when making standalone calls like our call to lock &amp; unlock the mutex, and to allocate memory as-needed for the global data array.</p>
<p>With some careful planning and well structured functions, this pattern can be quite effective, but it does take a surprising amount of effort.</p>
<p>I used to like the &quot;else if&quot; pattern quite a bit. Nowadays, the &quot;goto done&quot; pattern is my error handling method of choice. The &quot;goto done&quot; pattern is easier to read, write, and maintain.</p>

      <footer>
        <footer>
  <hr>
  <p>
    <center>
      Copyright ¬© 2020 Micah Snyder
      |
      <a href="https://twitter.com/_micahsnyder"><img src="https://abs.twimg.com/favicons/twitter.ico" width="20" height="20"></a>
      <a href="https://github.com/micahsnyder"><img src="https://github.githubassets.com/favicons/favicon-dark.png" width="20" height="20"></a>
      <a href="https://gitlab.com/micahsnyder"><img src="https://gitlab.com/assets/favicon-7901bd695fb93edb07975966062049829afb56cf11511236e61bcf425070e36e.png" width="20" height="20"></a>
    </center>
  </p>
  <br>
</footer>
      </footer>
    </div>
    <div class="rightDiv">
      <h3>Posts</h3>
      
        <p>
          &nbsp;&nbsp;<a href=https://blog.micahsnyder.dev/posts/2020-12-11-02-error-handling-in-c.html>Error Handling in C</a>
        </p>
      
        <p>
          &nbsp;&nbsp;<a href=https://blog.micahsnyder.dev/posts/2020-12-11-01-introduction.html>Introduction</a>
        </p>
      
    </div>
    <div "style: clear:both;"></div>
  </div>
</body>

</html>
